---
title: Nix flakes
snippet: |
  A system for referencing and sharing [Nix code](/concepts/nix-language)
related: ["channels"]
externalSources: [
  {
    title: "Flakes",
    href: "https://nixos.wiki/wiki/Flakes",
    source: {
      title: "The NixOS wiki",
      href: "https://nixos.wiki"
    }
  },
  {
    title: "Practical Nix flakes",
    href: "https://serokell.io/blog/practical-nix-flakes",
    source: {
      title: "The Serokell blog",
      href: "https://serokell.io/blog"
    }
  },
  {
    title: "Nix flakes: an introduction",
    href: "https://xeiaso.net/blog/nix-flakes-1-2022-02-21",
    source: {
      title: "Xe Iaso's blog",
      href: "https://xeiaso.net/blog"
    }
  }
]
---

<Admonition kind="warning" title="Flakes are experimental but nonetheless strongly recommended" id="flakes-warning" open client:load>
Nix flakes are currently an **experimental feature** in Nix and there is currently no specific timeline for making flakes official.
While the user interface around flakes is unlikely to change drastically while they remain experimental, there may be minor breaking changes along the way.

[Channels] will continue be the "official" way of using Nix for the foreseeable future.
We strongly recommend, however, that you learn to use flakes if you're already a Nix user or to begin your Nix journey with flakes rather than channels if you're just getting started with Nix.
</Admonition>

A Nix *flake* is a directory with a `flake.nix` and [`flake.lock`](#lockfile) at the root that [outputs](#outputs) Nix expressions that others can use to do things like [build packages][packages], [run programs][run], [import libraries](#lib)


Flakes were introduced to replace [channels], which remain the official system of depending on Nix code

Flakes take [flake inputs](/concepts/flake-inputs), such as [Nixpkgs](/concepts/nixpkgs), and provide [flake outputs](/concepts/flake-outputs) that other flakes can consume.

<Admonition kind="success" title="Mental model" client:load>
It may be helpful to think of flakes as I/O (input/output) for Nix code.
Flakes take Nix expressions as [input](#inputs) and [output](#outputs) things that Nix can use.
</Admonition>

## Flake references \{#references}

A *flake reference* is a string representation of where the flake is located.
Flake references are used in two places:

1. In flake [input declarations](#inputs)
1. On the command line when running commands like `nix run github:DeterminateSystems/riff` (which runs the [Riff] program)

Here are some example flake references:

Reference | Description
:---------|:-----------
`path:/home/nix-stuff/my-flake` | The `/home/nix-stuff/my-flake` directory on the current host
`github:DeterminateSystems/zero-to-nix` | The [DeterminateSystems/zero-to-nix][gh-z2n] GitHub repository
`github:DeterminateSystems/zero-to-nix/other` | The [`other`][other] branch of the [DeterminateSystems/zero-to-nix][gh-z2n] GitHub repository
`github:DeterminateSystems/zero-to-nix/d51c83a5d206e882a6f15a282e32b7079f5b6d76` | Commit [`d51c83a5d206e882a6f15a282e32b7079f5b6d76`][hash] on the [DeterminateSystems/zero-to-nix][gh-z2n] GitHub repository
`nixpkgs` | The most recent revision of the [`nixpkgs-unstable`][unstable] branch of [Nixpkgs] (an alias for `github:NixOS/nixpkgs`)
`nixpkgs/release-22.11` | The [`release-22.11`][22-11] branch of Nixpkgs

You can find a more systematic treatment of flake references in the [official documentation][refs-official].

## Flake inputs \{#inputs}

*Flake inputs* are Nix dependencies that a flake needs to be built.
Each input in the set can be pulled from various sources, such as github, generic git repositories, and even your filesystem.

Furthermore, inputs can modify each other's inputs to make sure that,
for example, multiple dependencies all rely on the same version of nixpkgs.
This is done via the `inputs.<input>.follows` attribute.

```nix filename=flake.nix
{
  inputs = {
    nixpkgs = "github:NixOS/nixpkgs";
  };
}
```

You can find a full breakdown of the flake input schema in the [Nix manual][manual].

### The `flake.lock` file \{#lockfile}

All flake inputs are [pinned] to specific revisions in a `flake.lock` lockfile.
This helps to ensure that Nix flakes are purely deterministic.

A `flake.nix` file without an accompanying `flake.lock` should be considered incomplete and a kind of proto-flake.
Any Nix CLI command that is run against the flake&mdash;like `nix build`, `nix develop`, or even `nix flake show`&mdash;generates a `flake.lock` for you.

### Flake registries \{#registries}

[*Flake registries*][registry-official] are a convenience feature that enables you to refer to flakes using symbolic identifiers rather than full flake references.
The most widely used symbolic identifier is `nixpkgs`, which is an alias for the `github:NixOS/nixpkgs/nixpkgs-unstable` flake [reference](#references)

Some symbolic identifiers that you may encounter:

Symbolic identifier | Full flake reference
:------------------|:-------------------
[`nixpkgs`][nixpkgs] | `github:NixOS/nixpkgs/nixpkgs-unstable`
[`flake-utils`][flake-utils] | `github:numtide/flake-utils`
[`home-manager`][hm] | `github:nix-community/home-manager`

The full default global flake registry is kept as a [JSON file][registry-json].

Here's an example flake that uses symbolic identifiers:

```nix filename=flake.nix
{
  outputs = { self, nixpkgs, flake-utils }:
    let
      pkgs = import nixpkgs { inherit system; };
    in flake-utils.lib.eachDefaultSystem (system: {
      devShells.default = pkgs.mkShell {
        packages = with pkgs; [ curl git jq wget ];
      };
    });
}
```

Note that the [`inputs` block](#inputs) has been omitted in this flake.
Using flake registries is always optional.

## Flake outputs \{#outputs}

*Flake outputs* are what a flake produces as part of its build.
Each flake can have many different outputs simultaneously, including but not limited to:

* [Nix packages][packages]
* [Nix development environments][env]
* [NixOS] configurations
* [Nix templates](#templates)

Flake outputs are defined by a function, which takes an attribute set as input, containing each of the inputs to that flake (named after the chosen identifier in the [inputs](#inputs) section).

### The `lib` output \{#lib}

In addition to things like packages and NixOS configurations, flakes can also output Nix functions and other values via the `lib` output.
Here's an example flake that outputs a `sayHello` function that takes a name as an input and outputs a string saying hello to that person:

```nix filename=flake.nix
{
  outputs = { self }: {
    lib = {
      sayHello = name: "Hello there, ${name}!";
    };
  };
}
```

Another Nix flake could then specify this flake as an [input](#inputs) and use `sayHello` for whatever purpose.
[Nixpkgs], for example, outputs a vast multitude of helper functions and values.

### System specificity

Some flake outputs need to be [system specific][specificity], including [packages], [development environments][env], and [NixOS] configurations.
Here's an example flake that outputs a package that can be used by `x86_64-linux` systems (64-bit AMD/Intel Linux):

```nix filename=flake.nix
{
  outputs = { self, nixpkgs }: let
    # Declare the system
    system = "x86_64-linux";
    # Use a system-specific version of Nixpkgs
    pkgs = import nixpkgs { inherit system; };
  in {
    # Output `cowsay` as the default package of the flake
    packages.${system}.default = pkgs.cowsay;
  };
}
```

In many cases, however, you'll need to output things like [packages] or [development environments][env] for multiple systems.
Helper libraries like [`flake-utils`][flake-utils] provide convenient mechanisms for doing that.
You can also use Nix functions like this:

```nix filename=flake.nix
{
  outputs = { self, nixpkgs }: let
    # Helper functions
    nameValuePair = name: value: { inherit name value; };
    genAttrs = names: f: builtins.listToAttrs (map (n: nameValuePair n (f n)) names);

    # The set of systems to provide outputs for
    allSystems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];

    # A function that provides a system-specific Nixpkgs for the desired systems
    forAllSystems = f: genAttrs allSystems (system: f {
      pkgs = import nixpkgs { inherit system; };
    });
  in {
    packages = forAllSystems ({ pkgs }: {
      default = {
        # Package definition
      };
    });
  };
}
```

## Flake templates \{#templates}

[*Flake templates*][init] enable you to either initialize a new Nix project with pre-supplied content or add a set of files to an existing project.
You can initialize a flake template using the [`nix flake init`][init] command.
Flakes can [output](#outputs) templates using the `templates` attribute.
Here's an example:

```nix filename=flake.nix
{
  outputs = { self }: {
    templates = {
      starter-template = {
        path = ./my-starter-template;
        description = "A getting started template for a new Nix project";
      };
    };
  };
}
```

If you ran `nix flake init --template <reference>` against this template definition, Nix would copy the contents of the `./my-starter-template` directory into the current directory (without overwriting existing files).

## Why you should use flakes \{#why}

Throughout Zero to Nix, we recommend using flakes regardless of where you are in your Nix journey.
If you're just getting started, we think you should learn flakes and mostly ignore channels;
if you're already a Nix user, you should begin switching any Nix logic you have&mdash;[NixOS] configurations, [development environment][env] definitions, and so on&mdash;to flakes.

But it's important to clarify *why* we think this:

* Flakes have a built-in [pinning] mechanism in the form of the [`flake.lock`](#lockfile) file.
  This ensures that flake inputs are always unambiguous.
* The problem with [channels] is that they're inherently stateful and thus ambiguous.
  The Nix expression `import <nixpkgs>`, for example, can refer to any number of revisions of [Nixpkgs].

[22-11]: https://github.com/nixOS/nixpkgs/tree/release-22.11
[channels]: /concepts/channels
[env]: /concepts/dev-env
[flake-utils]: https://github.com/numtide/flake-utils
[gh]: https://github.com
[gh-z2n]: https://github.com/DeterminateSystems/zero-to-nix
[hash]: https://github.com/DeterminateSystems/zero-to-nix/tree/d51c83a5d206e882a6f15a282e32b7079f5b6d76
[hm]: https://github.com/nix-community/home-manager
[init]: https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake-init
[manual]: https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake#flake-inputs
[nixos]: /concepts/nixos
[nixpkgs]: /concepts/nixpkgs
[other]: https://github.com/DeterminateSystems/zero-to-nix/tree/other
[packages]: /concepts/packages
[pinning]: /concepts/pinning
[refs-official]: https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake#flake-references
[registry-json]: https://github.com/NixOS/flake-registry/blob/master/flake-registry.json
[registry-official]: https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-registry
[riff]: https://riff.sh
[run]: /start/nix-run
[specificity]: /concepts/system-specificity
[unstable]: https://github.com/NixOS/nixpkgs/tree/nixpkgs-unstable
