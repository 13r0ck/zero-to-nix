---
title: Nix flakes
snippet: |
  A system for referencing and sharing [Nix code](/concepts/nix-language)
related: ["channels"]
externalSources: [
  {
    title: "Flakes",
    href: "https://nixos.wiki/wiki/Flakes",
    source: {
      title: "The NixOS wiki",
      href: "https://nixos.wiki"
    }
  },
  {
    title: "Practical Nix flakes",
    href: "https://serokell.io/blog/practical-nix-flakes",
    source: {
      title: "The Serokell blog",
      href: "https://serokell.io/blog"
    }
  },
  {
    title: "Nix flakes: an introduction",
    href: "https://xeiaso.net/blog/nix-flakes-1-2022-02-21",
    source: {
      title: "Xe Iaso's blog",
      href: "https://xeiaso.net/blog"
    }
  }
]
---

<Admonition kind="warning" title="Flakes are experimental but nonetheless strongly recommended" id="flakes-warning" open client:load>
Nix flakes are currently an **experimental feature** in Nix.

[Channels] will continue be the "official" way of using Nix for the foreseeable future.
We strongly recommend, however, that you learn to use flakes if you're already a Nix user or to begin your Nix journey with flakes rather than channels if you're just getting started with Nix.
</Admonition>

Nix *flakes* are a way of organizing and referring to Nix code that's pretty awesome. We think they're better than [channels](/concepts/channels).

Flakes take [flake inputs](/concepts/flake-inputs), such as [Nixpkgs](/concepts/nixpkgs), and provide [flake outputs](/concepts/flake-outputs) that other flakes can consume.

## Flake references \{#references}

A *flake reference* is a string representation of where the flake is located.
Flake references are used in two places:

1. In flake [input declarations](#inputs)
1. On the command line when running commands like `nix run github:DeterminateSystems/riff` (which runs the [Riff] program)

Here are some example flake references:

Reference | Description
:---------|:-----------
`path:/home/nix-stuff/my-flake` | The `/home/nix-stuff/my-flake` directory on the current host
`github:DeterminateSystems/zero-to-nix` | The [DeterminateSystems/zero-to-nix][gh-z2n] GitHub repository
`github:DeterminateSystems/zero-to-nix/other` | The [`other`][other] branch of the [DeterminateSystems/zero-to-nix][gh-z2n] GitHub repository
`github:DeterminateSystems/zero-to-nix/d51c83a5d206e882a6f15a282e32b7079f5b6d76` | Commit [`d51c83a5d206e882a6f15a282e32b7079f5b6d76`][hash] on the [DeterminateSystems/zero-to-nix][gh-z2n] GitHub repository
`nixpkgs` | The most recent revision of the [`nixpkgs-unstable`][unstable] branch of [Nixpkgs] (an alias for `github:NixOS/nixpkgs`)
`nixpkgs/release-22.11` | The [`release-22.11`][22-11] branch of Nixpkgs

You can find a more systematic treatment of flake references in the [official documentation][refs-official].

## Flake inputs \{#inputs}

*Flake inputs* are Nix dependencies that a flake needs to be built.
Each input in the set can be pulled from various sources, such as github, generic git repositories, and even your filesystem.

Furthermore, inputs can modify each other's inputs to make sure that,
for example, multiple dependencies all rely on the same version of nixpkgs.
This is done via the `inputs.<input>.follows` attribute.

```nix filename=flake.nix
{
  inputs = {
    nixpkgs = "github:NixOS/nixpkgs";
  };
}
```

You can find a full breakdown of the flake input schema in the [Nix manual][manual].

### The `flake.lock` file \{#lockfile}

All flake inputs are [pinned] to specific revisions in a `flake.lock` lockfile.
This helps to ensure that Nix flakes are purely deterministic.

### Flake registries \{#registries}

[*Flake registries*][registry-official] are a convenience feature that enables you to refer to flakes using symbolic identifiers rather than full flake references.
The most widely used symbolic identifier is `nixpkgs`, which is an alias for the `github:NixOS/nixpkgs/nixpkgs-unstable` flake [reference](#references)

Some symbolic identifiers that you may encounter:

Symbolic identifier | Full flake reference
:------------------|:-------------------
[`nixpkgs`][nixpkgs] | `github:NixOS/nixpkgs/nixpkgs-unstable`
[`flake-utils`][flake-utils] | `github:numtide/flake-utils`
[`home-manager`][hm] | `github:nix-community/home-manager`

The full default global flake registry is kept as a [JSON file][registry-json].

Here's an example flake that uses symbolic identifiers:

```nix filename=flake.nix
{
  outputs = { self, nixpkgs, flake-utils }:
    let
      pkgs = import nixpkgs { inherit system; };
    in flake-utils.lib.eachDefaultSystem (system: {
      devShells.default = pkgs.mkShell {
        packages = with pkgs; [ curl git jq wget ];
      };
    });
}
```

Note that the [`inputs` block](#inputs) has been omitted in this flake.
Using flake registries is always optional.

## Flake outputs \{#outputs}

*Flake outputs* are what a flake produces as part of its build.
Each flake can have many different outputs simultaneously, including but not limited to:

* [Nix packages][packages]
* [Nix development environments][env]
* [NixOS] configurations
* [Nix templates](#templates)

Flake outputs are defined by a function, which takes an attribute set as input, containing each of the inputs to that flake (named after the chosen identifier in the [inputs](#inputs) section).

The flake output below, for example, produces a single package output on `x86_64-linux` systems for the `cowsay` derivation.

```nix filename=flake.nix
{
  outputs = { self, nixpkgs }:
  let system = x86_64-linux;
  in
  {
    packages."${system}".default = (import nixpkgs { inherit system; }).cowsay;
  };
}
```

### System specificity

Some flake outputs need to be [system specific][specificity], including:

* [Packages]
* [NixOS]

## Flake templates \{#templates}

*Flake templates* enable you to either initialize a new Nix project or add files to an existing project.

You can initialize a flake template using the [`nix flake init`][init] command.

## Why you should use flakes \{#why}

Throughout Zero to Nix, we recommend using flakes regardless of where you are in your Nix journey.
If you're just getting started, we think you should learn flakes and mostly ignore channels;
if you're already a Nix user, you should begin switching any Nix logic you have&mdash;[NixOS] configurations, [development environment][env] definitions, and so on&mdash;to flakes.

But it's important to clarify *why* we think this:

* Flakes have a built-in [pinning] mechanism in the form of [`flake.lock`](#lockfile)

[22-11]: https://github.com/nixOS/nixpkgs/tree/release-22.11
[channels]: /concepts/channels
[env]: /concepts/dev-env
[flake-utils]: https://github.com/numtide/flake-utils
[gh]: https://github.com
[gh-z2n]: https://github.com/DeterminateSystems/zero-to-nix
[hash]: https://github.com/DeterminateSystems/zero-to-nix/tree/d51c83a5d206e882a6f15a282e32b7079f5b6d76
[hm]: https://github.com/nix-community/home-manager
[init]: https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake-init
[manual]: https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake#flake-inputs
[nixos]: /concepts/nixos
[nixpkgs]: /concepts/nixpkgs
[other]: https://github.com/DeterminateSystems/zero-to-nix/tree/other
[packages]: /concepts/packages
[pinning]: /concepts/pinning
[refs-official]: https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake#flake-references
[registry-json]: https://github.com/NixOS/flake-registry/blob/master/flake-registry.json
[registry-official]: https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-registry
[riff]: https://riff.sh
[specificity]: /concepts/system-specificity
[unstable]: https://github.com/NixOS/nixpkgs/tree/nixpkgs-unstable
